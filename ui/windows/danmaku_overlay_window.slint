import { DanmakuRow } from "../models.slint";

export component DanmakuOverlayWindow inherits Window {
    // Overlay window defaults to always-on-top; no toggle in the overlay UI.
    in-out property <bool> pin_on_top: true;
    in-out property <int> now_ms: 0;
    in property <length> speed_per_ms: 0.18px;
    in property <[DanmakuRow]> messages: [];

    callback close_clicked();
    callback begin_drag();

    title: "Danmaku Overlay";
    no-frame: true;
    // Let the backend provide native resize interactions for frameless windows.
    resize-border-width: 10px;
    always-on-top: root.pin_on_top;
    // Keep the overlay truly transparent so it can float above other apps.
    background: #00000000;

    // Keep controls away from the resize hit region (frameless window).
    property <length> safe_inset: 14px;
    property <length> titlebar_h: 56px;

    property <length> lane_height: 28px;
    // Reserve a top area so messages never pass under the close button.
    property <length> top_margin: titlebar_h;

    Rectangle {
        width: parent.width;
        height: parent.height;
        background: #00000000;
        border-width: 3px;
        border-color: #000000;
        border-radius: 8px;
        clip: true; // avoid text outside frame

        // Drag to move (exclude the close button area by splitting into two regions).
        // Declared early so subsequent controls appear "on top" for hit-testing.
        TouchArea {
            x: 0;
            y: 0;
            width: max(0px, parent.width - (safe_inset * 2 + 36px));
            height: titlebar_h;
            z: 0;
            mouse-cursor: move;
            pointer-event(pe) => {
                if (pe.button == PointerEventButton.left && pe.kind == PointerEventKind.down) {
                    root.begin_drag();
                }
            }
        }
        TouchArea {
            x: 0;
            y: titlebar_h;
            width: parent.width;
            height: parent.height - titlebar_h;
            z: 0;
            mouse-cursor: move;
            pointer-event(pe) => {
                if (pe.button == PointerEventButton.left && pe.kind == PointerEventKind.down) {
                    root.begin_drag();
                }
            }
        }

        // Close button (top-right)
        Rectangle {
            x: parent.width - self.width - safe_inset;
            y: safe_inset;
            z: 2;
            width: 36px;
            height: 28px;
            border-radius: 6px;
            // Use a light translucent background for readability over video content.
            background: close_area.has-hover ? #FFFFFFCC : #FFFFFFAA;
            border-width: 1px;
            border-color: #000000;

            Text {
                text: "×";
                width: parent.width;
                height: parent.height;
                horizontal-alignment: center;
                vertical-alignment: center;
                font-size: 16px;
                color: #000000;
            }

            close_area := TouchArea {
                width: parent.width;
                height: parent.height;
                mouse-cursor: pointer;
                clicked => { root.close_clicked(); }
            }
        }

        // (No explicit resize handle - edges/corners act as grips.)

        for msg[i] in root.messages: Rectangle {
            // Overlay only shows the message text (no username).
            x: root.width - (root.now_ms - msg.start_ms) * root.speed_per_ms;
            // Clamp Y so messages always stay within the window when the user resizes the overlay.
            y: min(
                max(root.top_margin, root.height - root.lane_height - root.safe_inset),
                root.top_margin + msg.lane * root.lane_height
            );
            height: root.lane_height;
            background: transparent;
            visible: root.now_ms < msg.end_ms;

            property <length> pad_x: 10px;
            property <length> bubble_max_w: max(0px, root.width - safe_inset * 2);
            property <length> img_w: msg.image_url != "" ? msg.image_w : 0px;
            property <bool> only_img: msg.image_url != "" && (msg.text == "[图片]" || msg.text == "[表情]");
            // Keep the hitbox tight to the content (text + optional image).
            property <length> bubble_w: min(
                bubble_max_w,
                probe.preferred-width + (msg.image_url != "" ? (img_w + 8px) : 0px)
            );

            // Make the moving message's bounding box fit the bubble for correct clipping.
            width: bubble_w;

            // Probe text: used only to measure preferred width (kept invisible and not interactive).
            probe := Text {
                text: msg.text;
                font-size: 19px;
                font-weight: 600;
                opacity: 0.0;
            }

            HorizontalLayout {
                width: parent.width;
                height: parent.height;
                spacing: 8px;
                alignment: start;

                Rectangle {
                    visible: msg.image_url != "";
                    width: img_w;
                    height: parent.height;
                    background: transparent;

                    Image {
                        width: parent.width;
                        height: parent.height;
                        source: msg.image;
                        image-fit: contain;
                    }

                    Text {
                        width: parent.width;
                        height: parent.height;
                        text: "IMG";
                        color: #FFFFFF;
                        opacity: 0.40;
                        font-size: 10px;
                        horizontal-alignment: center;
                        vertical-alignment: center;
                        visible: !msg.image_ready;
                    }
                }

                Text {
                    visible: !only_img;
                    text: msg.text;
                    horizontal-stretch: 1;
                    height: parent.height;
                    color: #FFFFFF;
                    opacity: 0.90;
                    font-size: 19px;
                    font-weight: 600;
                    vertical-alignment: center;
                    overflow: elide;
                }
            }
        }
    }
}
